a博客园Logo
 首页
 新闻
 博问
 专区
 闪存
 班级
 代码改变世界
 搜索
 注册
 登录

 sunshine
 博客园首页新随笔联系订阅管理随笔 - 20  文章 - 0  评论 - 2  阅读 - 72468
 Java多线程的三种实现方式
 今天简单说一下Java三种多线程实现方式和区别，主要有实现Runnable、Callable和继承Thread三种方式。

 实现Runnable的方式

 这种方式比较常用，当我们的线程类有继承其他的类的情况下（Java不支持类多继承），并且线程任务不需要返回值的情况下可以选用这种方式。

 复制代码
  1 public class ThreadRunnableDemo implements Runnable{
  2
  3     /** 计数变量 */
  4     private int count = 0;
  5
  6     public static void main(String[] args) throws InterruptedException {
  7
  8         ThreadRunnableDemo threadRunnableDemo = new ThreadRunnableDemo();
  9
 10         //实例化线程
 11         Thread thread = new Thread(threadRunnableDemo, "threadRunnableDemoA");
 12         System.out.println(String.format("线程状态preStart: %s", thread.getState()));
 13
 14         //启动线程
 15         thread.start();
 16         System.out.println(String.format("线程状态afterStart: %s", thread.getState()));
 17
 18         //主线程休眠1000ms
 19         Thread.sleep(1000);
 20         System.out.println(String.format("线程状态after1000ms: %s", thread.getState()));
 21
 22     }
 23
 24     @Override
 25     public void run() {
 26
 27         count++;
 28
 29         System.out.println(String.format("线程名称：%s, 线程状态：%s, count：%s",
 30                 Thread.currentThread().getName(), Thread.currentThread().getState(), count));
 31
 32     }
 33 }
 复制代码
 输出结果：

 1 线程状态preStart: NEW
 2 线程状态afterStart: RUNNABLE
 3 线程名称：threadRunnableDemoA, 线程状态：RUNNABLE, count：1
 4 线程状态after1000ms: TERMINATED


 实现Callable的方式

 当我们执行线程需要返回值的时候那么就必须选用实现Callable类的方式，因为目前只有这种方式能返回值。当然这种方式我们也可以不需要获取返回值。

 这种方式是通过FutureTask的get()方法（下面代码的第22行）或者get(long timeout, TimeUnit unit)（下面代码的第28行）方法获取返回值。当我们看Callable的接口定义的源码会发现“public interface Callable<V> ” ，我们实现的时候是需要定义返回类型，如下面代码所示。

 除此之外我们还需要注意的是：当我们通过FutureTask的get()方法去获取线程的返回值的时候是要等到线程call()内容都执行完毕之后才能获取得到，并且get()方法后面的代码必须等待，说明这一定是同步的，所以我们可以在真正需要线程返回值的时候才通过get()方法去获取，以免被阻塞。当我们通过get(long timeout, TimeUnit unit)方式去获取的时候可以设置超时时间，如果超过所设置的超时时间都没有获取到线程返回的值则会抛出 java.util.concurrent.TimeoutException 异常，当然如果在get(long timeout, TimeUnit unit)之前用get()方式获取了的话就不会抛异常。

 实现Callable还有个好处就是可以线程可以抛异常，如果我们需要在线程里抛出异常的话也可以选用这种方式，其他两种方式只能捕获异常信息。

 复制代码
  1 public class ThreadCallableDemo implements Callable<Integer>{
  2
  3     /** 计数变量 */
  4     private int count = 0;
  5
  6     public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException {
  7
  8         ThreadCallableDemo threadCallableDemo = new ThreadCallableDemo();
  9
 10         //通过FutureTask获取返回值
 11         FutureTask<Integer> taskA = new FutureTask<>(threadCallableDemo);
 12
 13         //实例化线程
 14         Thread thread = new Thread(taskA, "threadCallableDemoA");
 15         System.out.println(String.format("线程状态preStart: %s", thread.getState()));
 16
 17         //启动线程
 18         thread.start();
 19         System.out.println(String.format("线程状态afterStart: %s", thread.getState()));
 20
 21         //通过FutureTask的get()方法获取返回值
 22         int result = taskA.get();
 23         System.out.println("是否同步测试....");
 24         System.out.println(String.format("result: %s", result));
 25         System.out.println(String.format("线程状态afterGetResult1: %s", thread.getState()));
 26
 27         //通过FutureTask的get()方法获取返回值 设置超时时间 单位为ms
 28         int resultWithTime = taskA.get(100, TimeUnit.MILLISECONDS);
 29         System.out.println(String.format("resultWithTime: %s", resultWithTime));
 30         System.out.println(String.format("线程状态afterGetResult2: %s", thread.getState()));
 31
 32     }
 33
 34     /**
 35      * 实现Callable的call类
 36      */
 37     @Override
 38     public Integer call() throws Exception {
 39
 40         //自增
 41         count++;
 42
 43         System.out.println(String.format("线程名称：%s, 线程状态：%s, count：%s",
 44                     Thread.currentThread().getName(), Thread.currentThread().getState(), count));
 45         System.out.println("休眠1000ms....");
 46         Thread.currentThread().sleep(1000);
 47         return count;
 48     }
 49 }
 复制代码
 输出结果：

 复制代码
 1 线程状态preStart: NEW
 2 线程状态afterStart: RUNNABLE
 3 线程名称：threadCallableDemoA, 线程状态：RUNNABLE, count：1
 4 休眠1000ms....
 5 是否同步测试....
 6 result: 1
 7 线程状态afterGetResult1: TERMINATED
 8 resultWithTime: 1
 9 线程状态afterGetResult2: TERMINATED
 复制代码


 继承Thread的方式

 Thread类实际上也是实现Runnable接口，所以当我们继承Thread的时候我们即使不实现run()方法也不会报错，这种方式也经常用。

 下面我写了两种不同继承Thread的代码，大家可以看一下区别，我在网上看到很多人说 继承Thread实现多线程，线程间不能共享数据，但是我用下面的代码1方式似乎也可以共享哇，欢迎大家提出质疑。

 代码1：

 复制代码
  1 public class ThreadThreadDemo extends Thread{
  2
  3     /** 计数变量 */
  4     private int count = 0;
  5
  6     public static void main(String[] args) throws InterruptedException {
  7
  8         ThreadThreadDemo  threadThreadDemo = new ThreadThreadDemo();
  9
 10         //实例化线程
 11         Thread thread = new Thread(threadThreadDemo, "threadThreadDemoA");
 12         System.out.println(String.format("线程状态preStart: %s", thread.getState()));
 13
 14         //启动线程
 15         thread.start();
 16         System.out.println(String.format("线程状态afterStart: %s", thread.getState()));
 17
 18         //主线程休眠1000s
 19         Thread.sleep(1000);
 20         System.out.println(String.format("线程状态after1000ms: %s", thread.getState()));
 21     }
 22
 23     @Override
 24     public void run() {
 25
 26         count++;
 27
 28         System.out.println(String.format("线程名称：%s, 线程状态：%s, count：%s",
 29                 Thread.currentThread().getName(), Thread.currentThread().getState(), count));
 30     }
 31 }
 复制代码
 输出结果1：

 1 线程状态preStart: NEW
 2 线程状态afterStart: RUNNABLE
 3 线程名称：threadThreadDemoA, 线程状态：RUNNABLE, count：1
 4 线程状态after1000ms: TERMINATED
  代码2：

 复制代码
  1 public class ThreadThreadDemo extends Thread{
  2
  3     /** 计数变量 */
  4     private int count = 0;
  5
  6     public static void main(String[] args) throws InterruptedException {
  7
  8         ThreadThreadDemo  threadThreadDemo = new ThreadThreadDemo();
  9
 10         //实例化线程
 11         System.out.println(String.format("线程状态preStart: %s", threadThreadDemo.getState()));
 12
 13         //启动线程
 14         threadThreadDemo.start();
 15         System.out.println(String.format("线程状态afterStart: %s", threadThreadDemo.getState()));
 16
 17         //主线程休眠1000s
 18         Thread.sleep(1000);
 19         System.out.println(String.format("线程状态after1000ms: %s", threadThreadDemo.getState()));
 20     }
 21
 22     @Override
 23     public void run() {
 24
 25         count++;
 26
 27         System.out.println(String.format("线程名称：%s, 线程状态：%s, count：%s",
 28                 Thread.currentThread().getName(), Thread.currentThread().getState(), count));
 29     }
 30 }
 复制代码
 输出结果2：

 1 线程状态preStart: NEW
 2 线程状态afterStart: RUNNABLE
 3 线程名称：Thread-0, 线程状态：RUNNABLE, count：1
 4 线程状态after1000ms: TERMINATED


 最后总结：

 如果不要求线程返回结果，也不需要抛异常也没有继承其他的类，那么三种方式可以任选，看喜好；
 如果有继承其他类，那么就只能用实现Runnable和实现Callable的方式；
 如果需要线程返回结果或者需要线程抛异常那么选择实现Callable的方式的方式，但是需要注意的是获取返回结果是同步的方式。
 如果有疑问或者有问题欢迎留言讨论！

 下面是我的个人公众号，欢迎关注，一起学习，可以方便看我的文章！



 分类: 多线程
 标签: Thread, Runnable, Callable, 多线程, java
 好文要顶 关注我 收藏该文
 dengyongchang
 关注 - 8
 粉丝 - 5
 +加关注
 00
 « 上一篇： 教你如何快速定制 SpringBoot banner
 » 下一篇： 金融行业是如何丢失1分钱的
 posted @ 2020-01-14 01:43  dengyongchang  阅读(1506)  评论(0)  编辑  收藏
 刷新评论刷新页面返回顶部
 登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
 【推荐】开发者藏经阁，160本电子书免费下载！阿里工程师实践精华
 【推荐】大型组态、工控、仿真、CAD\GIS 50万行VC++源码免费下载!
 【推荐】HMS Core Discovery 有奖直播--探索天谕手游的幻想世界
 【推荐】限时秒杀！国云大数据魔镜，企业级云分析平台

 园子动态：
 · 致园友们的一封检讨书：都是我们的错
 · 数据库实例 CPU 100% 引发全站故障
 · 发起一个开源项目：博客引擎 fluss

 最新新闻：
 · “掠夺”淘宝：这才是字节跳动上市的秘密武器？
 · 继云计算巨头失火事件后，微软决定送数据中心去“泡澡”！
 · 怪兽充电上市、街电搜电合并，共享充电宝在急什么？
 · 从顶梁柱到拖油瓶，B站游戏能否重回巅峰？
 · 顺丰发一季度业绩预告：估亏11亿
 » 更多新闻...
 昵称： dengyongchang
 园龄： 4年7个月
 粉丝： 5
 关注： 8
 +加关注
 <	2021年4月	>
 日	一	二	三	四	五	六
 28	29	30	31	1	2	3
 4	5	6	7	8	9	10
 11	12	13	14	15	16	17
 18	19	20	21	22	23	24
 25	26	27	28	29	30	1
 2	3	4	5	6	7	8
 搜索


 常用链接
 我的随笔
 我的评论
 我的参与
 最新评论
 我的标签
 我的标签
 java(7)
 javascript(3)
 IntelliJ IDEA(2)
 spring boot(2)
 文件下载(2)
 二级联动(2)
 浮点型(1)
 BigDecimal(1)
 精度丢失(1)
 Thread(1)
 更多
 积分与排名
 积分 - 32207
 排名 - 35367
 随笔分类
 Java(9)
 JavaScript(4)
 powerdesigner(1)
 spring boot(3)
 多线程(1)
 前后端分离(2)
 随笔档案
 2020年3月(1)
 2020年1月(1)
 2019年6月(3)
 2019年4月(1)
 2019年1月(2)
 2018年9月(1)
 2018年3月(1)
 2018年2月(1)
 2018年1月(1)
 2016年11月(1)
 2016年10月(3)
 2016年9月(3)
 2016年8月(1)
 最新评论
 1. Re:关于富文本编辑器—UEditor（java版）的使用，以及如何将UEditor的文件/图片上传路径改成绝对路径
 详细~~
 --柏格云
 2. Re:前后端分离，导出数据为文件或下载文件，前端如何处理后端返回的数据
 mark
 --MyCoolDog
 阅读排行榜
 1. 前后端分离，导出数据为文件或下载文件，前端如何处理后端返回的数据(20725)
 2. 利用JavaScript来实现省份—市县的二级联动(11408)
 3. java主函数的含义(10274)
 4. 关于富文本编辑器—UEditor（java版）的使用，以及如何将UEditor的文件/图片上传路径改成绝对路径(8858)
 5. 通过Ajax异步提交的方法实现从数据库获取省份和城市信息实现二级联动（xml方法）(3666)
 评论排行榜
 1. 关于富文本编辑器—UEditor（java版）的使用，以及如何将UEditor的文件/图片上传路径改成绝对路径(1)
 2. 前后端分离，导出数据为文件或下载文件，前端如何处理后端返回的数据(1)
 推荐排行榜
 1. 5分钟学会如何创建spring boot项目(2)
 2. 关于富文本编辑器—UEditor（java版）的使用，以及如何将UEditor的文件/图片上传路径改成绝对路径(1)
 3. 文件下载的ie11兼容性优化(1)
 4. 前后端分离，导出数据为文件或下载文件，前端如何处理后端返回的数据(1)
 Copyright © 2021 dengyongchang
 Powered by .NET 5.0 on Kubernetes